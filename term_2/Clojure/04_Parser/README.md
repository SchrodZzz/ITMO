1.  **Простой вариант.** Реализуйте функцию `(parseObjectSuffix "expression")`, разбирающую выражения, записанные в суффиксной форме, и функцию `toStringSuffix`, возвращающую строковое представление выражения в этой форме. Например,
    `(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))`
    должно возвращать `((2 x *) 3 -)`.
2.  **Сложный вариант.** Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в инфиксной форме, и функцию `toStringInfix`, возвращающую строковое представление выражения в этой форме. Например,
    `(toStringInfix (parseObjectInfix "2 * x - 3"))`
    должно возвращать `((2 * x) - 3)`.
3.  **Бонусный вариант.** Добавьте в библиотеку комбинаторов возможность обработки ошибок и продемонстрируйте ее использование в вашем парсере.
4.  Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

#### Модификации
*   _Базовая_
    *   Код должен находиться в файле `expression.clj`.
    *   [Исходный код тестов](/git/geo/paradigms-2019/src/master/clojure/cljtest/parsing/ClojureObjectParsingTest.java)
        *   Запускать c аргументом `easy` или `hard`
*   _Variables_. Дополнительно реализовать поддержку: **_(works)_**
    *   Переменных, состоящих из произвольного количества букв `XYZ` в любом регистре
        *   Настоящее имя переменной определяется первой буквой ее имени
    *   [Исходный код тестов](/git/geo/paradigms-2019/src/master/clojure/cljtest/parsing/ClojureVariablesParsingTest.java)
*   _PowLog_. Дополнительно реализовать поддержку:
    *   Бинарных правоассоциативных операций максимального приоритета:
        *   `Pow` (`**`) – возведения в степень: `4 ** 3 ** 2` равно `4 ** (3 ** 2)` равно 262144
        *   `Log` (`//`) – взятия логарифма: `8 // 9 // 3` равно `8 // (9 // 3)` равно 3
    *   [Исходный код тестов](/git/geo/paradigms-2019/src/master/clojure/cljtest/parsing/ClojurePowLogParsingTest.java)
